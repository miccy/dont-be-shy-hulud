#!/usr/bin/env bash
# ==============================================================================
# suspend-malware.sh - Safe Shai-Hulud Process Suspension
# ==============================================================================
#
# CRITICAL: This script uses SIGSTOP instead of SIGKILL/SIGTERM to prevent
# triggering the malware's "dead man's switch" that wipes $HOME directory.
#
# Usage:
#   ./suspend-malware.sh              # Interactive mode
#   ./suspend-malware.sh --auto       # Auto-suspend without confirmation
#   ./suspend-malware.sh --dry-run    # Show what would be suspended
#   ./suspend-malware.sh --resume     # Resume (unfreeze) suspended processes
#
# ==============================================================================

set -euo pipefail

# Colors
RED='\033[0;31m'
YELLOW='\033[1;33m'
GREEN='\033[0;32m'
BLUE='\033[0;34m'
CYAN='\033[0;36m'
NC='\033[0m' # No Color
BOLD='\033[1m'

# Process signatures to look for
PROCESS_SIGNATURES=(
    "bun_environment.js"
    "setup_bun.js"
    "node_bun_shim"
    "bun_environment"
    "trufflehog"
    ".truffler-cache"
)

# State file for tracking suspended processes
STATE_FILE="${HOME}/.shai-hulud-suspended-pids"

# Flags
DRY_RUN=false
AUTO_MODE=false
RESUME_MODE=false


# ==============================================================================
# Functions
# ==============================================================================

print_banner() {
    echo -e "${CYAN}"
    echo "â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—"
    echo "â•‘  â„ï¸  SHAI-HULUD SAFE PROCESS SUSPENSION                          â•‘"
    echo "â•‘                                                                  â•‘"
    echo "â•‘  âš ï¸  Uses SIGSTOP to FREEZE processes without triggering wiper   â•‘"
    echo "â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•"
    echo -e "${NC}"
}

print_warning() {
    echo -e "${RED}${BOLD}"
    echo "â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”"
    echo "â”‚  âš ï¸  CRITICAL SAFETY WARNING                                    â”‚"
    echo "â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤"
    echo "â”‚  DO NOT:                                                        â”‚"
    echo "â”‚   âŒ Kill processes with SIGKILL (kill -9)                      â”‚"
    echo "â”‚   âŒ Kill processes with SIGTERM (kill -15)                     â”‚"
    echo "â”‚   âŒ Disconnect network before freezing                         â”‚"
    echo "â”‚   âŒ Reboot without backup                                      â”‚"
    echo "â”‚                                                                 â”‚"
    echo "â”‚  These actions may trigger the WIPER that deletes \$HOME!       â”‚"
    echo "â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜"
    echo -e "${NC}"
}

log_info() {
    echo -e "${BLUE}[INFO]${NC} $1"
}

log_success() {
    echo -e "${GREEN}[âœ“]${NC} $1"
}

log_warning() {
    echo -e "${YELLOW}[âš ]${NC} $1"
}

log_error() {
    echo -e "${RED}[âœ—]${NC} $1"
}

log_frozen() {
    echo -e "${CYAN}[â„ï¸]${NC} $1"
}

# Find suspicious processes
find_suspicious_processes() {
    local pids=()

    for sig in "${PROCESS_SIGNATURES[@]}"; do
        # Use pgrep with -f for full command line matching
        while IFS= read -r pid; do
            if [[ -n "$pid" ]]; then
                pids+=("$pid")
            fi
        done < <(pgrep -f "$sig" 2>/dev/null || true)
    done

    # Remove duplicates
    printf '%s\n' "${pids[@]}" | sort -u
}

# Get process details
get_process_info() {
    local pid=$1
    ps -p "$pid" -o pid,ppid,user,%cpu,%mem,stat,start,command 2>/dev/null | tail -n +2
}

# Check if process is already stopped
is_process_stopped() {
    local pid=$1
    local state
    state=$(ps -o stat= -p "$pid" 2>/dev/null || echo "")
    [[ "$state" == *"T"* ]]
}

# Freeze a single process
freeze_process() {
    local pid=$1

    if ! kill -0 "$pid" 2>/dev/null; then
        log_warning "Process $pid no longer exists"
        return 1
    fi

    if is_process_stopped "$pid"; then
        log_info "Process $pid is already stopped"
        return 0
    fi

    if $DRY_RUN; then
        log_info "[DRY-RUN] Would freeze process $pid"
        return 0
    fi

    # Send SIGSTOP (signal 19) - this freezes the process
    if kill -STOP "$pid" 2>/dev/null; then
        log_frozen "Process $pid has been FROZEN (SIGSTOP)"
        echo "$pid" >> "$STATE_FILE"
        return 0
    else
        log_error "Failed to freeze process $pid"
        return 1
    fi
}

# Resume a single process
resume_process() {
    local pid=$1

    if ! kill -0 "$pid" 2>/dev/null; then
        log_warning "Process $pid no longer exists"
        return 1
    fi

    if ! is_process_stopped "$pid"; then
        log_info "Process $pid is not stopped"
        return 0
    fi

    if $DRY_RUN; then
        log_info "[DRY-RUN] Would resume process $pid"
        return 0
    fi

    # Send SIGCONT (signal 18) - this resumes the process
    if kill -CONT "$pid" 2>/dev/null; then
        log_success "Process $pid has been RESUMED (SIGCONT)"
        return 0
    else
        log_error "Failed to resume process $pid"
        return 1
    fi
}

# Main freeze operation
do_freeze() {
    local pids
    mapfile -t pids < <(find_suspicious_processes)

    if [[ ${#pids[@]} -eq 0 ]]; then
        log_success "No suspicious processes found based on known signatures"
        echo ""
        echo "Checked signatures:"
        for sig in "${PROCESS_SIGNATURES[@]}"; do
            echo "  - $sig"
        done
        return 0
    fi

    echo -e "${YELLOW}${BOLD}âš ï¸  SUSPICIOUS PROCESSES FOUND:${NC}"
    echo ""
    echo "PID     PPID    USER       %CPU  %MEM  STAT  START     COMMAND"
    echo "------  ------  ---------  ----  ----  ----  --------  -------"

    for pid in "${pids[@]}"; do
        get_process_info "$pid"
    done

    echo ""

    if ! $AUTO_MODE && ! $DRY_RUN; then
        echo -e "${YELLOW}Do you want to FREEZE these processes? [y/N]${NC} "
        read -r response
        if [[ ! "$response" =~ ^[Yy]$ ]]; then
            log_info "Operation cancelled by user"
            return 0
        fi
    fi

    echo ""
    local frozen_count=0

    for pid in "${pids[@]}"; do
        if freeze_process "$pid"; then
            ((frozen_count++))
        fi
    done

    echo ""
    if [[ $frozen_count -gt 0 ]]; then
        log_success "Frozen $frozen_count process(es)"
        echo ""
        echo -e "${CYAN}${BOLD}ğŸ“‹ NEXT STEPS:${NC}"
        echo "  1. Create a backup/snapshot of your system NOW"
        echo "  2. Document the frozen processes for forensics"
        echo "  3. Check for exfiltration repos: ./scripts/check-github-repos.sh"
        echo "  4. Follow remediation guide: docs/REMEDIATION.md"
        echo ""
        echo -e "${YELLOW}âš ï¸  DO NOT REBOOT until you have backups!${NC}"
        echo ""
        echo "To resume processes (after backup): $0 --resume"
    fi
}

# Resume operation
do_resume() {
    if [[ ! -f "$STATE_FILE" ]]; then
        log_info "No suspended processes state file found"
        log_info "Looking for stopped processes with known signatures..."

        local pids
        mapfile -t pids < <(find_suspicious_processes)

        for pid in "${pids[@]}"; do
            if is_process_stopped "$pid"; then
                echo "Found stopped process: $pid"
                get_process_info "$pid"
            fi
        done
        return 0
    fi

    log_warning "Resuming processes from $STATE_FILE"
    echo ""

    if ! $AUTO_MODE && ! $DRY_RUN; then
        echo -e "${RED}âš ï¸  WARNING: Resuming malware processes may cause damage!${NC}"
        echo -e "${YELLOW}Only do this if you have backups and understand the risks.${NC}"
        echo ""
        echo "Are you SURE you want to resume these processes? [yes/NO] "
        read -r response
        if [[ "$response" != "yes" ]]; then
            log_info "Operation cancelled"
            return 0
        fi
    fi

    local resumed_count=0

    while IFS= read -r pid; do
        if [[ -n "$pid" ]]; then
            if resume_process "$pid"; then
                ((resumed_count++))
            fi
        fi
    done < "$STATE_FILE"

    if ! $DRY_RUN; then
        rm -f "$STATE_FILE"
    fi

    log_success "Resumed $resumed_count process(es)"
}

# Parse arguments
parse_args() {
    while [[ $# -gt 0 ]]; do
        case $1 in
            --dry-run|-n)
                DRY_RUN=true
                shift
                ;;
            --auto|-y)
                AUTO_MODE=true
                shift
                ;;
            --resume|-r)
                RESUME_MODE=true
                shift
                ;;

            --help|-h)
                print_banner
                echo "Usage: $0 [OPTIONS]"
                echo ""
                echo "Options:"
                echo "  --dry-run, -n    Show what would be done without doing it"
                echo "  --auto, -y       Auto-confirm without prompting"
                echo "  --resume, -r     Resume (unfreeze) previously suspended processes"

                echo "  --help, -h       Show this help message"
                echo ""
                echo "Examples:"
                echo "  $0               # Interactive mode - scan and freeze"
                echo "  $0 --dry-run     # See what would be frozen"
                echo "  $0 --auto        # Auto-freeze without confirmation"
                echo "  $0 --resume      # Resume frozen processes (after backup)"
                exit 0
                ;;
            *)
                log_error "Unknown option: $1"
                echo "Use --help for usage information"
                exit 1
                ;;
        esac
    done
}

# ==============================================================================
# Main
# ==============================================================================

main() {
    parse_args "$@"

    print_banner

    if ! $RESUME_MODE; then
        print_warning
    fi

    if $DRY_RUN; then
        log_info "Running in DRY-RUN mode - no changes will be made"
        echo ""
    fi

    if $RESUME_MODE; then
        do_resume
    else
        do_freeze
    fi
}

main "$@"
